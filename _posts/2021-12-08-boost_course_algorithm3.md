---
layout : archive
title : Unit 2 - Insertion Sort & Merge Sort
categories : Boost_Course_Algorithm_by_Python
use_math : true
---

# 정렬에 관심을 가져야 하는 이유

---

응용 사례는 많지만 대표적으로 전화번호부를 관리한다고 할 때 많은 이름들과 그에 매칭되는 전화번호들이 있다. 이것들을 포함하여 많은 것들이 정렬된 순서로 보관해야 검색이나 파일 관리, 스프레드시트 등에서 다루기 쉬울 것이다. 또한 정렬이 되면 해결하기 쉬워지는 문제들도 존재한다. 중간값을 찾는 것이나 이진탐색이 대표적인 예시이다. (숫자가 아니라면 레코드의 정렬을 위해 비교함수가 추가적으로 필요하다.) 이는 정렬의 부산물과 같은 것으로 크기n이 홀수 인지 짝수인지만 확인하여 n/2번째 숫자만 확인하면 중간값을 찾을 수 있고, 원하는 숫자를 찾기 위한 탐색을 할 때 이진 탐색을 통해 시간 복잡도를 $\theta{n}$에서 $\theta{log{n}}$으로 줄일 수 있다. 이 탐색은 매우 좋은 분할 정복 알고리즘이다. 이와 같이 정렬된 배열이 있다면 쉬워지는 문제들이 종종 있다. 그러나 위의 사례와 달리 간단하지 않은 사례들도 있다. 예를 들어 데이터 압축과 컴퓨터 그래픽이 그 예시이다. 이처럼 다양한 종류의 복잡한 프로그램에서 정렬은 굉장히 중요한 서브루틴이다. 그리고, 각각의 정렬 알고리즘들은 저마다의 존재 이유가 있다. 어떤 경우에는 입력 값의 종류나 문제의 종류에 따라 가장 빠른 알고리즘이 달라지기 때문이다.

---

# 삽입정렬과 합병정렬

## 삽입정렬

---

1. 장점
  a. 제자리 정렬
  b. 쉽고 간단한 구조

2. 단점
  a. $\theta(n^2)$의 시간 복잡도

---

### C언어로 구현된 삽입정렬
```cpp

void InsertionSort (int *A){
	for(int key = 1; key < n; key++){
		for (int temp = key - 1; temp >= 0; temp--){
			if (A[temp] > A[temp + 1])
				Swap(&A[temp], &A[temp + 1]);
			else
				break;
    }
  }
}

```

### 알고리즘 설명

---

1. 첫 번쨰 원소는 하나 밖에 없고 이미 정의 상으로 정렬되어 있기 때문에 key를 두번째 원소 혹은 인덱스 1부터 시작한다.
2. key는 자신보다 작은 숫자를 만나기 전까지 자신의 왼쪽에 있는 숫자와 자리를 바꾼다.
3. 작은 숫자를 만나면 교환을 멈추고 key를 오른쪽으로 한 칸 움직인다.
4. key가 배열의 크기인 n이 될 때까지 2 ~ 3단계를 반복한다.
5. key = n이 될 때 즉시 종료한다.

---

### 복잡도

---

최악의 경우는 내림차순의 배열을 오름차순으로 정렬하는 경우로(반대의 경우도 동일)
배열의 크기를 n이라고 하자. 임의의 양수인 정수 m에 대하여 key = m일때, m-1번의 비교와 교환이 필요하다.
key는 1부터 n-1까지 이동하므로
연산의 횟수는
$$\sum_{k = 1}^n-1 m = n^2 - n = \theta(n^2)$$

위의 복잡도는 대부분의 컴퓨터에서 그렇듯이 비교와 교환이 각각 동일하게 하나의 연산이라는 가정하에 계산된 것이다.
하지만 숫자가 아닌 레코드의 경우 레코드 비교 함수가 그 자체로 메소드나 호출 서브루틴이라면 포인터가 참조를 교환하는 것만으로도 교환할 수 있지만, 비교는 대체적으로 더 복잡하므로 보통 교환보다 더 높은 비용이 든다.

위의 $\theta(n^2)$ 알고리즘의 경우 $\theta(n^2)$번의 비교를 하고 $\theta(n^2)$번의 교환을 한다.
이를 $\theta(n\log n)$의 수준의 알고리즘으로 개선할 수 있을까?
비교 횟수를 n이라고 할 때 이진탐색을 사용하여 비교횟수를 줄일 수는 있다. 하지만, 이 경우 A[i]를 A[0:i-1]에 삽입하게 되는데, 이때 삽입위치의 숫자와 그 오른쪽의 숫자들을 전부 오른쪽으로 한 칸씩 옮겨야하므로 교환횟수는 줄지 않는다.
이처럼 비교와 교환의 비용에 관계없이 제대로 된 $\theta(n\log n)$ 알고리즘은 존재하지는 않는다.

---


## 합병 정렬

---

1. 장점
  a. $\theta(n\log(n))$의 시간복잡도


2. 단점
  a. $\theta(n)$의 추가적인 공간이 필요

---


### C언어로 구현된 합병 정렬
```cpp

void MergeSort(int *A, int bot, int top, int *B)
{
	if (bot >= top)
		return;

	int mid = (bot + top) / 2;

	MergeSort(A, bot, mid, B);
	MergeSort(A, mid + 1, top, B);

	int Left = bot, Right = mid + 1, B_index = bot;

	while (B_index <= top)
	{
		if(Left > mid)
			B[B_index++] = A[Right++];
		else if (Right > top)
			B[B_index++] = A[Left++];
		else if (A[Left] <= A[Right])
			B[B_index++] = A[Left++];
		else
			B[B_index++] = A[Right++];
	}

	for (int temp = bot; temp <= top; temp++)
		A[temp] = B[temp];
}


```


### 알고리즘 설명
---

1. 분할
  a. A배열을 절반의 크기의 배열 짝 L, R로 분할한다.
  b. 위의 단계를 분할이 되지 않을 때까지 반복한다.

2. 정복
  a. 크기가 1인 배열은 정의상 정렬이 된 것으로 간주한다.
  b. 정렬이 된 배열은 다시 자신의 배열 짝과 합병하며 정렬하여 임시배열 B에 저장한다.
  c. B에 저장된 배열을 A에 복사한다.
  d. 분할된 배열들이 전부 합병, 정렬되어 A에 복사될 때까지 b ~ c 단계를 반복한다.

---

### 복잡도

---

1. 합병
  배열 A의 크기가 n이라고 가정하고, 임의의 양수인 정수 a, b에 대하여 ab = n일 때, 임의의 합병단계에서 배열의 크기는 모두 a, 배열은 모두 b개 존재한다고 하자.
  각각의 짝 배열과 원소들을 각각 비교하여 배열 B에 삽입 후 배열 A에 복사한다.
  이를 계산해보면 비교 $\frac{n}{2} ~ n - \alpha$번, 배열 B에 삽입 n번, 배열 A에 복사 n번이므로 $\theta(n)$번의 연산이 필요하다.

2. 분할
  배열의 크기는 n이며, 배열의 크기가 1이 될 때까지 분할된다. 임의의 양수인 정수 m에 대하여, 배열 A가 m번 분할이 되면 배열의 크기가 1이 된다고 하면,
  $\frac{n}{2}^m = 1$
  $n = 2^m$
  $m = \log(n)$
  따라서, 분할은 log(n)번 된다.

위의 계산에 따라 각 합병 단계에는 $\theta(n)$번의 연산이 필요하고, 합병 단계의 수는 분할 단계의 수와 같으므로 $log(n)$번이고 따라서 알고리즘의 복잡도는 $\theta(n\log(n))$이다.

---

필요한 공간을 줄이도록 개선한 제자리 합병 정렬도 존재하긴 하나 이는 약간 비실용적은 측면이 존재한다. 상수 인자 수준 정도로 성능이 좋지 않기 때문이다. 제자리 정렬이더라도 여전히 theta(nlog(n))이지만 실행시간이 theta(n)의 보조공간을 쓰는 일반 합병 정렬보다 훨씬 좋지 않다. 그래서 제자리 합병 정렬을 잘 쓰지 않는다.

수적인 관점에서 몇 년전 실험을 했었다. 완료된 실험이 아니라 정확하진 않을 수 있는데 파이썬으로 그래프를 그리는 프로그램을 짰는데 합병 정렬은 2.2nlog(n) microsecond가 걸렸다. 파이썬에서 삽입정렬의 경우에는 0.2n^2 microsecond이다. 여기 상수 인자를 보면 컴파일 언어인 C언어에서 삽입정렬을 한다면 훨씬 더빠르다. 20배 정도 빠르다. 0.01n^2 microsecond이다. 그래서 이것이 더 실용적이다. 여러분도 코드를 짜보길 바란다. 이건 중요하다. 알고리즘에 관심있는 이유가 그것을 실행하기 위한 것이기 때문이다. 알 수 있는 것은 n을 찾을 수 있다는 것이다. C언어든 파이썬이든 관계없이 말이다. 점근적 복잡도가 꽤 중요하다는 것을 의미한다. n이 약 4000을 넘긴다면 파이썬의 합병 정렬이 C언의 삽입정렬을 이긴다. n이 특정 값 이상을 넘으면 상수 인자들은 의미가 없어진다. 그래서 점근적 복잡도가 중요하다. 여기서 인자는 20배 차이가 난다. 하지만 n^2알고리즘과 경쟁할 경우 상수들은 거의 의미가 없다. 좀 더 오랫동안 괜찮을 수 있지만 결국은 느려져서 뒤쳐지게 된다.
