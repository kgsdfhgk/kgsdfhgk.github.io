---
layout : archive
title : Unit 2 - Insertion Sort & Merge Sort
categories : Boost_Course_Algorithm_by_Python
use_math : true
---

# 정렬에 관심을 가져야 하는 이유

---

많은 것들이 정렬된 순서로 보관하면 검색이나 파일 관리, 스프레드시트 등에서 다루기 쉬울 것이다. 또한, 정렬이 되면 해결하기 쉬워지는 문제들도 존재한다. 중간값을 찾는 것이나 이진탐색이 대표적인 예시이다. (숫자가 아니라면 레코드의 정렬을 위해 비교함수가 추가적으로 필요하다.) 이는 정렬의 부산물과 같은 것으로 크기 n이 홀수 인지 짝수인지 확인하여 n/2번째 숫자만 확인하면 중간값을 찾을 수 있고, 원하는 숫자를 찾기 위한 탐색을 할 때 이진 탐색을 통해 시간 복잡도를 $\theta(n)$에서 $\theta(log(n))$으로 줄일 수 있다. 그러나, 이런 사례와 달리 간단하지 않은 사례들도 있다. 예를 들어 데이터 압축과 컴퓨터 그래픽이 그 예시이다. 이처럼 다양한 종류의 복잡한 프로그램에서 정렬은 굉장히 중요한 서브루틴이다. 위의 다양한 사례에 적용되는 각각의 정렬 알고리즘들은 저마다의 존재 이유가 있다. 어떤 경우에는 입력 값의 종류나 문제의 종류에 따라 가장 빠른 알고리즘이 달라지기 때문이다.

---

# 삽입정렬과 합병정렬

## 삽입정렬

---

1. 장점<br>
  a. 제자리 정렬<br>
  b. 쉽고 간단한 구조

2. 단점<br>
  a. $\theta(n^2)$의 시간 복잡도

---

### C언어로 구현된 삽입정렬
```cpp

void InsertionSort (int *A){
	for(int key = 1; key < n; key++){
		for (int temp = key - 1; temp >= 0; temp--){
			if (A[temp] > A[temp + 1])
				Swap(&A[temp], &A[temp + 1]);
			else
				break;
    }
  }
}

```

### 알고리즘 설명

---

1. 첫 번째 원소는 하나 밖에 없고 이미 정의 상으로 정렬되어 있기 때문에 key를 두번째 원소 혹은 인덱스 1부터 시작한다.
2. key는 자신보다 작은 숫자를 만나기 전까지 자신의 왼쪽에 있는 숫자와 자리를 바꾼다.
3. 작은 숫자를 만나면 교환을 멈추고 key를 오른쪽으로 한 칸 움직인다.
4. key가 배열의 크기인 n이 될 때까지 2 ~ 3단계를 반복한다.
5. key = n이 될 때 즉시 종료한다.

---

### 복잡도

---

최악의 경우는 내림차순의 배열을 오름차순으로 정렬하는 경우다.
(반대의 경우도 동일) 배열의 크기를 n이라고 하자.
임의의 양수인 정수 m에 대하여 key = m일때, m-1번의 비교와 교환이 필요하다.
key는 1부터 n-1까지 이동하므로 연산의 횟수는<br>
$\sigma_{k = 1}^n-1 m = n^2 - n = \theta(n^2)$

위의 복잡도는 대부분의 컴퓨터에서 그렇듯이 비교와 교환이 각각 동일하게 하나의 연산이라는 가정하에 계산된 것이다.<br>
하지만 숫자가 아닌 레코드의 경우 비교는 대체적으로 더 복잡하므로 보통 교환보다 더 높은 비용이 든다.

위의 $\theta(n^2)$ 알고리즘의 경우 $\theta(n^2)$번의 비교와 교환을 한다. 이를 $\theta(n\log n)$의 수준의 알고리즘으로 개선할 수 있을까?<br>
비교 횟수를 n이라고 할 때 이진탐색을 사용하여 비교횟수를 줄일 수는 있다. 하지만, 이 경우 A[i]를 A[0:i-1]에 삽입하게 되는데, 이때 삽입위치의 숫자와 그 오른쪽의 숫자들을 전부 오른쪽으로 한 칸씩 옮겨야하므로 교환횟수는 줄지 않는다.
이처럼 비교와 교환의 비용에 관계없이 제대로 된 $\theta(n\log n)$ 알고리즘은 존재하지는 않는다.

---


## 합병 정렬

---

1. 장점<br>
  a. $\theta(n\log(n))$의 시간복잡도


2. 단점<br>
  a. $\theta(n)$의 추가적인 공간이 필요

---


### C언어로 구현된 합병 정렬
```cpp

void MergeSort(int *A, int bot, int top, int *B)
{
	if (bot >= top)
		return;

	int mid = (bot + top) / 2;

	MergeSort(A, bot, mid, B);
	MergeSort(A, mid + 1, top, B);

	int Left = bot, Right = mid + 1, B_index = bot;

	while (B_index <= top)
	{
		if(Left > mid)
			B[B_index++] = A[Right++];
		else if (Right > top)
			B[B_index++] = A[Left++];
		else if (A[Left] <= A[Right])
			B[B_index++] = A[Left++];
		else
			B[B_index++] = A[Right++];
	}

	for (int temp = bot; temp <= top; temp++)
		A[temp] = B[temp];
}


```


### 알고리즘 설명
---

1. 분할<br>
  a. A배열을 절반의 크기의 배열 짝 L, R로 분할한다.<br>
  b. 위의 단계를 분할이 되지 않을 때까지 반복한다.

2. 정복<br>
  a. 크기가 1인 배열은 정의상 정렬이 된 것으로 간주한다.<br>
  b. 정렬이 된 배열은 다시 자신의 배열 짝과 합병하며 정렬하여 임시배열 B에 저장한다.<br>
  c. B에 저장된 배열을 A에 복사한다.<br>
  d. 분할된 배열들이 전부 합병, 정렬되어 A에 복사될 때까지 b ~ c 단계를 반복한다.

---

### 복잡도

---

1. 합병
  배열 A의 크기를 n, 임의의 양수인 정수 a, b에 대하여 ab = n, 임의의 합병단계에서 배열의 크기는 모두 a, 배열은 모두 b개 존재한다고 하자.<br>
  각각의 짝 배열과 원소들을 각각 비교하여 배열 B에 삽입 후 배열 A에 복사한다.
  이를 계산해보면 비교 $\frac{n}{2}$ ~ $n - \alpha$번, 배열 B에 삽입 n번, 배열 A에 복사 n번이므로 $\theta(n)$번의 연산이 필요하다.

2. 분할
  배열의 크기는 n이며, 배열의 크기가 1이 될 때까지 분할된다. 임의의 양수인 정수 m에 대하여, 배열 A가 m번 분할이 되면 배열의 크기가 1이 된다고 하면,<br>
  $(\frac{n}{2})^m = 1$<br>
  $n = 2^m$<br>
  $m = \log(n)$<br>
  따라서, 분할은 log(n)번 된다.

위의 계산에 따라 각 합병 단계에는 $\theta(n)$번의 연산이 필요하고,<br>합병 단계의 수는 분할 단계의 수와 같으므로 $log(n)$번이고, 따라서 알고리즘의 복잡도는 $\theta(n\log(n))$이다.

---

제자리 합병 정렬도 존재하긴 하나 이는 약간 비실용적은 측면이 존재한다. 제자리 정렬이더라도 여전히 theta(nlog(n))이지만 실행시간이 theta(n)의 보조공간을 쓰는 일반 합병 정렬보다 훨씬 좋지 않다. 그래서 제자리 합병 정렬을 잘 쓰지 않는다.
