---
layout : archive
title : "6월 01일 프로그래머스 Level3 단속카메라"
categories : "코딩 테스트"
use_math : true
---

# 문제

문제 설명

고속도로를 이동하는 모든 차량이 고속도로를 이용하면서 단속용 카메라를 한 번은 만나도록 카메라를 설치하려고 합니다.

고속도로를 이동하는 차량의 경로 routes가 매개변수로 주어질 때, 모든 차량이 한 번은 단속용 카메라를 만나도록 하려면 최소 몇 대의 카메라를 설치해야 하는지를 return 하도록 solution 함수를 완성하세요.

<br>

제한사항

 - 차량의 대수는 1대 이상 10,000대 이하입니다.
 - routes에는 차량의 이동 경로가 포함되어 있으며 routes[i][0]에는 i번째 차량이 고속도로에 진입한 지점, routes[i][1]에는 i번째 차량이 고속도로에서 나간 지점이 적혀 있습니다.
 - 차량의 진입/진출 지점에 카메라가 설치되어 있어도 카메라를 만난것으로 간주합니다.
 - 차량의 진입 지점, 진출 지점은 -30,000 이상 30,000 이하입니다.

## 소요시간
 - 대략 90분
 - 0531 2240 ~ 0601 0010

## 접근방식
 1. 첫번째 방식
  - size 60001의 vector<vector<int>> vec 선언.
  - vec의 index 0 부터 60001까지 각각 차량이 지나는 지점인 -30000 ~ 30000에
  해당한다고 생각하고 각 지점에 차량이 지나가는 경우 해당하는 차량 번호를 각 지점마다 push_back 해준다. (ex. 첫 번째 차량이 [-30000, -29999]를 지난다면, vec[0].push_back(0), vec[1].push_back(0)을 해준다.)
  - vec의 원소들 중 size가 가장 큰 순서대로 골라서 고른 원소의 원소들에 해당하는 부분을 routes에서 제거 (ex. 지워야하는 차량번호가 0, 1, 2라면 routes[0], routes[1], routes[2] 제거)
  - routes가 비워질 때 까지 위의 과정을 반복
  - 폐기한 이유
      - 공간 낭비
      - 난잡해 보이는 과정
      - 이전 코딩테스트들에서 체감했던 vector에서의 원소 제거의 비효율성
      - 주어지는 routes를 건드리지 않고 가능한 방식의 (불명확한) 아이디어 떠오름


 2. 두번째 방식
  - (가정) 고속도로가 일차선 도로이고 역주행이 불가능하다.
  - routes를 각 원소의 첫 원소를 기준으로 오름차순 정렬
  (routes[i][0] 기준으로 정렬 / i in [0, routes.size()))
  - routes의 앞 부분부터 겹쳐지지 않는 routes의 원소가 나올 때까지 겹치고 size가 2인 int형 배열 arrange에 저장.<br>
  (ex. routes[0] = {-10, -5}, routes[1] = {-9, -6}, routes[2] = {-4, -1}의 경우 arrange = {-9, -6})
  - 겹쳐지지 않는 routes의 원소가 나올 경우 answer++ 하고 arrange에 겹쳐지지 않는 routes의 원소 저장
  - routes의 마지막 원소 직전까지 위의 두가지 과정 반복
  - routes의 마지막 원소가 arrange와 겹쳐질 경우 answer++ / 안 겹쳐질 경우 answer += 2
  - 풀이 성공

## 개선이 필요한 부분
 - 코드의 간결화(?)



## 참고했던 사항
 -


## 참고하면 좋은 알고리즘
 -
