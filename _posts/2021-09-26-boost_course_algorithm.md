---
layout : archive
title : Chapter 1 - 강의 소개 및 극댓값 찾기
categories : Boost_Course_Algorithm_by_Python
use_math : true
---

## 1차원에서 찾기
<br><br>
1차원에서의 극댓값 찾기는 숫자 배열에 시작된다

|arr[0]|arr[1]|arr[2]|arr[3]|arr[4]|arr[5]|arr[6]|arr[7]|arr[8]|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| a | b | c | d | e | f | g | h | i |

a ~ i 가 양수인 상수라고 가정해보자


2번째 자리가 극댓값이라는 것은 b >= a 와 b >= c를 만족하는 것이다.

만약에 i >= h 이면 arr[8]도 극댓값이다.
(가장자리이기 떄문)

가장 쉽게 찾는 방법은 왼쪽부터 차례대로 조건에 맞는지 확인해보는 것이다.

배열에 왼쪽부터 1부터 n까지 들어있다고 가정해보자
1<= m <=n 인 값 m에 대하여 m이 극댓값이라고 한다면
최악의 경우 복잡도는 $\theta(n)$이다.

### 학생 질문
---
Question)
문제의 정의에 따르면 극댓값은 항상 존재하는데 왜 존재할 경우라는 말이 있는가?<br><br>

Answer)
만약 극댓값의 정의가 달랐다면 존재하지 않을 수 있다.<br>
(ex. 극댓값 : 주변보다 크거나 같다 -> 크다)<br>
문제의 정의가 달라진다거나 변형된 문제 또한 공략할 수 있는 보편적인 알고리즘을 만들고자 하는 것이 **알고리즘적** 사고이다

어떤 문제를 해결해 달라는 일을 맡았을 때, 모든 경우에 해당하는 조건을 찾지 못할 수도 있고, 아무리 노력해도 답이 안 보이는 문제들도 종종 존재한다.<br>
이럴 때 자신이 노력했다는 흔적을 남기는 것이 중요하며, '특정 조건 하에 답이 이렇고 다른 조건 하에서는 도저히 모르겠다' 라는 말을 할 수 있다.

---
<br>


만약에 이진 탐색을 활용한다면 복잡도를 좀 더 줄일 수 있는데 이진 탐색은 재귀적이자 분할 정복 알고리즘이다.

이진 탐색은

$1, 2, ..., \frac{n}{2}-1, \frac{n}{2}, \frac{n}{2}+1, .... n-1, n$

의 배열이 있을 때

만약 $a[\frac{n}{2}] < a[\frac{n}{2}-1]$ 이라면 $\frac{n}{2}$ 의 왼쪽인 1 ~ $\frac{n}{2}-1$만 확인하고, 만약 $a[\frac{n}{2}] < a[\frac{n}{2}+1]$ 이라면 오른쪽만 확인하고 둘 다 아니라면 $a[\frac{n}{2}]$가 극댓값인 것을 확인할 수 있는 알고리즘이다.

이 알고리즘의 증명은 제쳐두고(맞다고 하고) 복잡도를 계산해보자
이 재귀적, 분할 정복 알고리즘에 대응하는 T(n) 점화식을 세워보자.

- $T(n) = T(\frac{n}{2}) + \theta(1)$
- base case : $T(1) = \theta(1)$
- $T(n) = \theta(1)\log_2 n$
- $T(n) = \theta(\log_2 n)$

## 2차원에서 찾기

n개의 행, m개의 열을 가진 행렬에 대하여 특정 위치의 값이 극댓값이 되기 위한 조건은 그 위치의 값이 주변(위, 아래, 양 옆)보다 더 크거나 같은 것이다.

가장 간단한 알고리즘 예시로 greedy ascent algorithm은 방향을 찾고 그 방향을 따라 극댓값을 찾는다
ex) 4방위에서 자신의 값보다 큰 값이 있으면 그 쪽으로 계속 따라는 것

이러한 특정 시작지점에서 특정 방향으로 탐색하는 이 알고리즘의 최악의 경우 복잡도는 $\theta(nm)$이고 $n = m$일때 $\theta(n^2)$이다.

분할정복에 대해 생각해보자.

시도 1)<br>
이진 탐색 알고리즘을 2차원에 집어 넣는다고 생각해보자

1. $j = \frac{m}{2}$을 잡고 1차원에서의 극댓값 위치를 찾는다. 이를 $(i, j)$라고 하자.
2. i행에서 극댓값을 찾는 위치 시작점을 $(i, j)$로 잡고 찾는다.

이 방법은 효율적일 수 있으나, 부정확한 알고리즘이다.
이 알고리즘의 문제점은 i행에서 극댓값이 존재하지 않을 수 있는 것이다.

시도 2)<br>
1. $j = \frac{m}{2}$로 잡고 j열에서 가장 큰 값의 위치를 $(i, j)$라고 하자.
2. $(i, j)$을 $(i, j-1), (i, j+1)$의 값들과 순서대로 비교한다.
3. $(i, j-1)$값이 더 크면 왼쪽 열을 선택, $(i, j+1)$값이 더 크면 오른쪽 열을 선택하고 다시 1번으로 돌아가 실행한다.
4. 둘 다 $(i, j)$의 값보다 작으면 $(i, j)$는 j열에서 가장 큰 값이므로 이 위치가 극댓값 위치가 된다.

여기서 base case는 하나의 열만이 남아 이 열의 가장 큰 값을 찾으면 끝이 난다.

복잡도를 계산해보면

- $T(n, m) = T(n, \frac{m}{2}) + \theta(n)$
- $T(n, 1) = \theta(n)$
- $T(n, m) = \theta(n\log_2 m)$

이다.
